% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
% Math packages and custom macros for this manuscript
\usepackage{amsmath,amssymb}
\newcommand{\R}{\mathbb{R}}
\newcommand{\vect}[1]{\boldsymbol{#1}}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{Lung Tissue Stiffness Estimation via Spring Mass System and Graph Convolutional Networks}
%
\titlerunning{Lung Tissue Stiffness Estimation}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{First Author\inst{1}\orcidID{0000-1111-2222-3333} \and
Second Author\inst{2,3}\orcidID{1111-2222-3333-4444} \and
Third Author\inst{3}\orcidID{2222--3333-4444-5555}}
%
\authorrunning{Annonymous et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Princeton University, Princeton NJ 08544, USA \and
Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
\email{lncs@springer.com}\\
\url{http://www.springer.com/gp/computer-science/lncs} \and
ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
\email{\{abc,lncs\}@uni-heidelberg.de}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
The abstract should briefly summarize the contents of the paper in
150--250 words.

\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}


Chronic Obstructive Pulmonary Disease (COPD) is a paradigmatic example of a condition in which 
altered tissue mechanics play a central role in disease progression and spatial heterogeneity. 
Lung tissue stiffness (elastic modulus) can vary dramatically between healthy and diseased regions, 
reflecting underlying structural changes in the parenchyma. 
Fibrotic remodeling increases tissue rigidity through excess extracellular‑matrix deposition,
and such stiffening has been linked to disease severity in fibrosis and cancer. 
In contrast, emphysema is characterized by destruction and enlargement of airspaces, 
loss of elastic recoil, and abnormally low tissue stiffness. 
Many COPD patients display a mixture of localized fibrosis and emphysema, 
so global lung function metrics (such as spirometry) tend to mask regional dysfunction. 
Accurate, high‑resolution maps of regional lung elasticity would therefore be highly valuable: 
they could help identify and characterize diseased subregions in heterogeneous lungs, 
guide focal therapies, and enable personalized tracking of COPD progression.

Noninvasive elastography techniques attempt to quantify stiffness by applying mechanical vibrations 
and imaging the resulting deformations. Magnetic resonance elastography (MRE), 
for instance, uses motion‑encoding gradients to capture shear wave propagation 
and is now widely used to stage liver fibrosis.\cite{pollack2021deep} 
However, translating these ideas to the lungs has proven extremely challenging. 
The rib cage and chest wall absorb or attenuate externally induced vibrations,
limiting wave penetration into the lung parenchyma; 
respiratory motion complicates displacement measurements and destabilizes the inverse reconstruction; 
and the air content of lung tissue severely limits both MRI signal and ultrasound transmission. 
As a result, there is currently no routine elastography modality for the lungs, 
and clinicians lack a direct imaging biomarker of regional lung elasticity.

To circumvent these limitations, several groups have turned to medical imaging
and biomechanical modeling. Respiratory‑gated 4D CT can capture lung motion over
the breathing cycle~\cite{keall2006management}, and finite‑element models of lung mechanics 
have been used to explore how spatially varying stiffness influences 
deformation~\cite{parameswaran2011linking,suki2011lung,ito2005mechanics}. In principle, one can
pose a PDE‑constrained inverse problem: estimate a 3D elasticity field such that the
simulated deformations match those observed in 4D CT~\cite{zhang2018inverse,hasse2017estimation}. 
In practice, this problem is severely ill‑posed and computationally 
demanding~\cite{hasse2017estimation}. Many stiffness distributions can
produce similar displacement fields unless strong regularization is imposed, and tra-
ditional approaches require case‑by‑case optimization that is far too slow for clinical
use~\cite{zhang2018inverse}. Moreover, 4D CT itself is not routinely acquired in COPD care 
because of radiation dose and scanner time~\cite{mori2009effective}, 
further limiting the practicality of purely model‑based elastography.

Deep learning appears to offer an attractive alternative by learning statistical links between 
image appearance and tissue mechanics. In earlier work on the liver\cite{pollack2021deep}, 
we trained convolutional neural networks to predict liver stiffness directly from routine MR images, 
using MRE‑derived elastograms as supervision. Although these models captured coarse trends—distinguishing, 
for example, clearly stiff from clearly soft livers—their voxel‑wise accuracy 
and generalization across scanners and protocols were limited. 
Performance degraded outside the distribution of the training data, 
and the networks tended to regress toward population‑average stiffness 
values rather than recovering fine‑scale mechanical heterogeneity. 
More fundamentally, such approaches require paired imaging and elastography data for training, 
which are not available for the lungs.

We also explored a more physics‑driven strategy on synthetic data: 
using a differentiable implicit spring–mass system (SMS) \cite{baraff2023large} to simulate 
the motion of heterogeneous spring mass phantoms and training neural networks 
to recover the underlying stiffness pattern 
from observed deformations. 
In that setting we coupled a 3D convolutional network to an implicit SMS implemented and 
attempted to learn stiffness parameters solely by minimizing the discrepancy between simulated 
and target motion. However, back‑propagating through the implicit solver 
and its sparse linear algebra proved numerically fragile; 
gradients were noisy and the learned stiffness fields were almost indistinguishable from random guesses, 
despite visually reasonable motion fields. 
%\begin{figure}[h]
%    \centering
%    \includegraphics[width=0.45\textwidth]{hierarchy_transformer.png}
%    \includegraphics[width=0.45\textwidth]{3d_unet.png}
%    \caption{We tried to use Unet or Transformer to directly learn the mapping from displacement to stiffness on synthetic data, 
%    but both models failed to produce meaningful results. 
%    Left: Vision Transformer Prediction; Right: 3D Unet Prediction.
%    }
%\end{figure}
A more stable variant, in which a CNN or transformer was supervised directly with ground‑truth stiffness 
maps generated by the simulator, did learn to predict material patterns on the training distribution, 
but only because it was given explicit labels rather than inferring material properties from physics.
These experiments reinforced an important lesson: naïve deep networks, even when coupled to a simulator, 
do not automatically "discover" constitutive parameters from kinematic data; 
without carefully designed physical structure and priors, the inverse problem remains ill‑posed.



Motivated by these observations, we adopt a different point of view in this work and develop 
a physics‑informed learning framework tailored to lung mechanics. Instead of asking a network 
to infer stiffness solely from motion or from scarce elastography labels, 
we combine (i) strong image‑based priors derived from CT Hounsfield units and lung anatomy, 
with (ii) an explicit, differentiable model of lung elasticity that is enforced during training. 
Concretely, we represent the lung parenchyma with a tetrahedral mesh and 
use a small‑strain, axis‑aligned SMS discretization of static equilibrium as our forward physical model. 
A graph convolutional network (GCN) defined on the mesh predicts a spatial field of stiffness 
parameters (shear moduli) from CT‑derived features and mesh connectivity. During training, 
these predicted stiffness fields are passed through the SMS layer to simulate quasi‑static deformations 
under measured boundary conditions; the resulting displacements are compared to those obtained 
from 4D CT registration, and the GCN parameters are updated to minimize this physics‑guided discrepancy, 
together with regularization terms that promote spatial smoothness and scale‑invariant stiffness variations.

In this sense, our approach is "physics‑informed" but differs from classical 
physics ‑informed neural networks: the PDE is solved with a conventional (but differentiable) 
discretization, and the neural network is used only to propose material parameters 
rather than to represent the displacement field itself. Crucially, 
the heavy PDE‑constrained optimization is amortized across the training cohort. 
Once trained, the GCN can map a single inspiratory CT scan to a full 3D stiffness distribution 
on the mesh in one forward pass, without any per‑patient inverse solve.

In summary, this work introduces a lung elastography framework that combines 
(1) an axis‑aligned SMS discretization of small‑strain elasticity suited for efficient GPU implementation, 
(2) a mesh‑based GCN that predicts element‑wise stiffness from routine CT‑derived features, 
and (3) a PDE‑constrained training procedure 
that enforces biomechanical consistency using deformation data extracted from 4D CT. 
We demonstrate on a controlled drooped‑cone experiment that the SMS discretization 
faithfully approximates standard finite‑element solutions and enables accurate recovery of 
heterogeneous stiffness. We then apply the full SMS+GCN framework to Emory 4D CT data 
and show that the recovered stiffness maps highlight emphysematous regions and capture
expected basal–to–apical stiffness gradients in COPD lungs, 
suggesting that physics‑informed learning can provide clinically meaningful estimates of
regional lung mechanics from standard imaging.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Methodology}
\subsection{Problem Setting and Notations}

In continuum mechanics, the local deformation is characterized by the deformation 
gradient $F$, which maps an infinitesimal material line element in the reference 
configuration to its image in the current configuration via $dx = F dX$.
For example, consider a single 2D triangular finite element with reference vertices 
$X_1, X_2, X_3 \in \mathbb{R}^2$ and current vertices $x_1, x_2, x_3 \in \mathbb{R}^2$. 
In a constant strain triangle, the deformation is assumed affine over the element,

$$
x(X)=F X+b
$$

with constant $F \in \mathbb{R}^{2 \times 2}$ and translation $b \in \mathbb{R}^2$. 
Under this assumption, the statement $d x=F d X$ holds everywhere inside the triangle: 
every infinitesimal direction is transformed by the same linear operator $F$, 
which is precisely why the element strain is constant.

A practical way to compute $F$ is to use the element edges as a local basis. 
Define the reference and current edge matrices

$$
D_m=\left[\begin{array}{ll}
X_2-X_1 & X_3-X_1
\end{array}\right], \quad D_s=\left[\begin{array}{ll}
x_2-x_1 & x_3-x_1
\end{array}\right]
$$


Because an affine map sends reference edges to current edges, one has $D_s=F D_m$, and therefore

$$
F=D_s D_m^{-1}
$$

provided the reference triangle is nondegenerate (so $D_m$ is invertible). 
Intuitively, $D_m$ encodes the two in-plane directions and lengths of the reference triangle, 
$D_s$ encodes their deformed versions, and $F$ is the unique linear transformation that 
matches one to the other.
Strain is introduced as a measure of deformation that removes rigid motion 
and retains only changes in lengths and angles. 
This viewpoint emerges directly from how $F$ changes the metric. 
The squared length of a reference line element is $d S^2=d X^{\top} d X$, 
while the squared length after deformation is

$$
d s^2=d x^{\top} d x=(F d X)^{\top}(F d X)=d X^{\top}\left(F^{\top} F\right) d X .
$$


The deformation $F$ usually consists an orthogonal rotation tensor $R$ 
and a symmetric right stretch tensor $U$: $F=R U$. To isolate the pure stretch component,
we introduce the right Cauchy-Green deformation tensor:
$$
C=F^{\top} F = (RU)^{\top} (RU) = U^{\top} R^{\top} R U = U^{T}U .
$$
which describes, from the reference perspective, how squared lengths are scaled in every direction. 
A key sanity check is rotational invariance: if the deformation is a pure rigid rotation $F=R$ with $R^{\top} R=I$, then $C=I$ and no strain is detected, matching the physical expectation that rotation alone should not generate internal deformation.
And as we remove the rotatation, $C$ directly encodes the stretch information via $U$.
A standard finite-deformation strain measure derived from $C$ is the Green-Lagrange strain:

$$
E=\frac{1}{2}(C-I),
$$

which can be interpreted as a normalized change in the reference metric. 
In the small-deformation regime, writing the displacement 
as $u(X)=x(X)-X$ leads to $F=I+\nabla_X u$, and the familiar smallstrain tensor appears as
$$
\varepsilon=\frac{1}{2}\left(\nabla u+(\nabla u)^{\top}\right) .
$$
Here the diagonal entries correspond to relative extension/compression 
along coordinate directions, while the off-diagonal entries represent shear (angle change). 
For a CST element, $\nabla u$ is constant within the triangle, 
hence $\varepsilon$ is also constant-exactly the "constant strain" property.

For a line element aligned with a material basis direction, e.g., 
$dX = ds e_\ell$, the mapping becomes $dx = ds (F e_\ell)$. 
This shows that $F e_\ell$ is the deformed direction vector associated 
with the unit material direction $e_\ell$ 
(the push-forward of that direction), 
and it encodes how both the magnitude and orientation of that direction 
change under deformation.
In the following we analyze the strain energy density based on these deformed
direction vectors. Firstly, given the axis directions $\{e_1,e_2,e_3\}$, we will build
the Energy Density function based on the deformation gradient $F$:
\begin{equation} 
  U_k(F)=V_k\left[\frac{\alpha}{2} 
  \sum_{\ell=1}^3\left(\left\|F e_{\ell}\right\|^2-1\right)^2+\frac{\beta}{2} 
  \sum_{\ell<m}\left[\left(F e_{\ell}\right) \cdot\left(F e_m\right)\right]^2+
  \frac{\kappa}{2}(J-1)^2\right]
\end{equation} 
Then we will derive a quadratic approximation of this energy density. Now let's explain each term in the energy density function:

\subitem Stretch (length-change) penalty along the basis directions

The term $\sum_{\ell=0}^{2}\big(\lVert F e_\ell\rVert^2 - 1\big)^2$ penalizes deviations of the 
squared stretch along each basis direction from its reference value. 
Since $\lVert e_\ell\rVert = 1$ in the reference configuration, $\lVert F e_\ell\rVert$ 
directly measures the stretch of a unit segment initially aligned with $e_\ell$. T
he expression $(\lVert F e_\ell\rVert^2 - 1)$ therefore 
quantifies whether that direction has been elongated or compressed, 
and squaring it enforces a symmetric penalty for tension and compression while strongly 
discouraging large departures from the undeformed length.

\subitem Shear / loss of orthogonality penalty via deformed dot products.

The term $\sum_{\ell<m}\big[(F e_\ell)\cdot(F e_m)\big]^2$
targets changes in the angles between material directions, 
i.e., shear-like distortions. If ${e_1,e_2,e_3}$ is an orthonormal basis 
in the reference configuration, then $e_\ell\cdot e_m=0$ for $\ell\neq m$, 
corresponding to right angles. After deformation, 
$(F e_\ell)\cdot(F e_m)=\lVert F e_\ell\rVert,\lVert F e_m\rVert\cos\theta_{\ell m}$, 
so a nonzero dot product indicates a departure from orthogonality. 
Because the dot product is not normalized, 
this measure couples angle change with stretch; 
however, when the stretch deviations are already controlled by the length-penalty term, 
this contribution effectively acts as a direct penalty on angular distortion (shear).

\subitem  Volumetric penalty and compressibility control.

The volumetric term $\frac{\kappa}{2}(J-1)^2$ with $J=\det F$ 
penalizes local changes in volume, since (J) is the Jacobian determinant relating differential 
volumes: $dV_{\text{current}} = J dV_{\text{reference}}$. 
The constraint $J=1$ corresponds to local volume preservation, 
while $J>1$ and $J<1$ represent expansion and compression, respectively. 
The parameter $\kappa$ controls compressibility: 
increasing it progressively discourages volumetric change and approaches an 
incompressible response in the limit of very large values.


Geometrically, the three vectors $\{F e_1, F e_2, F e_3\}$ 
can be viewed as the images of three orthonormal material directions forming a local “micro-cell.” 
The first term constrains how much each of these edges changes length, 
the second term constrains whether the edges remain orthogonal 
(thereby suppressing shear and shape distortion), 
and the third term constrains the volume change of the associated infinitesimal neighborhood. 
When implemented per element (e.g., per tetrahedron), 
multiplying the energy density by the element volume $V_k$ 
converts it into a physically scaled element energy. 
Finally, these quantities admit a compact expression through the right 
Cauchy–Green tensor $C = F^\top F$: $(\lVert F e_\ell\rVert^2)$ 
corresponds to diagonal components of $C$ in the $(e_\ell)$ basis, 
while $((F e_\ell)\cdot(F e_m))$ corresponds to the off-diagonal components—making 
the “length + angle” structure explicit.


\subsection{Topology for Volumetric Mesh}
\subsubsection{Intersection Points \& Coefficient Matrix}
In each tetrahedral element $\mathcal V_k$, we precompute six
intersection points $\{q_j\}_{j=1}^6$ by ray-casting from the
\textbf{barycenter} $x_b$ along the three anisotropy axes
$\{e_0,e_1,e_2\}$ until they intersect the element faces
\cite{bourguignon2000anisotropy,lakhal2013modified}.
At the same time we build a $4\times 6$ coefficient matrix $C^k$ whose
columns contain the shape-function values at these intersections.
This matrix lets us reconstruct each $q_j$ as a linear combination of
the four vertex positions, in both reference and deformed configurations.
\newline
Let $x_i$ be the coordinates of the four vertices of $\mathcal V_k$.
The barycenter is $ x_b \;=\;\frac{1}{4}\sum_{i=1}^4 x_i.$
Consider a triangular face $\Delta_{i_1i_2i_3}$ of the tetrahedron
with vertices $x_{i_1},x_{i_2},x_{i_3}$. A ray from $x_b$ along one
anisotropy axis intersects that face at a point $q_j$ (if at all).
Let $S_{\Delta_{abc}}$ denote the (signed) area of triangle
$\Delta_{abc}$. Then $q_j$ lies inside $\Delta_{i_1i_2i_3}$ if and only if
$S_{\Delta_{i_1i_2i_3}}=
S_{\Delta_{q_j\,i_2\,i_3}}
+ S_{\Delta_{i_1\,q_j\,i_3}}
+ S_{\Delta_{i_1\,i_2\,q_j}}.$
    

In that case the (area) barycentric coordinates of $q_j$ on this face are
\begin{equation}
    \xi=\frac{S_{\Delta_{q_j\,i_2\,i_3}}}{S_{\Delta_{i_1i_2i_3}}},\quad
    \eta=\frac{S_{\Delta_{q_j\,i_1\,i_3}}}{S_{\Delta_{i_1i_2i_3}}},\quad
    1-\xi-\eta=\frac{S_{\Delta_{i_1\,i_2\,q_j}}}{S_{\Delta_{i_1i_2i_3}}}.
    \tag{2.24}
    \label{eq:barycentric_coords}
\end{equation}

Then we can building the coefficient matrix $C^k$. For each intersection point $q_j$ we evaluate the four linear
shape functions $N_i$ of the tetrahedron at $q_j$.
On the face $\Delta_{i_1i_2i_3}$ that actually contains $q_j$,
these shape functions coincide with the barycentric coordinates:
\[
\begin{cases}
    N_{i_1}(q_j)=1-\xi-\eta,\\
    N_{i_2}(q_j)=\xi,\\
    N_{i_3}(q_j)=\eta,\\
    N_{i_4}(q_j)=0,
\end{cases}
\]
where $\{i_1,i_2,i_3\}$ are the face vertices and $i_4$ is the
opposite vertex of the tetrahedron. We then define
\[
  C^k_{ij} \;=\; N_i\bigl(q_j\bigr),
\]
so that $C^k\in\mathbb R^{4\times 6}$ has column $j$ equal to the
four shape-function values at intersection $q_j$. In other words,
each intersection can be reconstructed from the vertex positions
as a convex combination:
\[
  q_j \;=\;\sum_{i=1}^4 C^k_{ij}\,x_i.
\]


In the implementation, the six intersection points $q_j$ and the
corresponding coefficient matrix $C^k$ are precomputed in the
reference configuration and then reused to update $x_j^t$ at every
time step or load step. 
\subsubsection{Axis of Anisotropy Definition}
In \cite{bourguignon2000anisotropy}, the anisotropy axes are obtained from the data.
But in our case, we do not have such data. So we define the anisotropy axes by using svd on
deformation gradient \cite{sin2011invertible,irving2004invertible}.

For each tetrahedral element we attach an orthonormal frame of three unit vectors 
($e_0, e_1, e_2$) that encodes the local axes of anisotropy in the reference configuration. 
These directions are meant to follow the dominant deformation of the element as estimated from 
image registration, and they are the axes used later when we define axial and shear components 
of the strain energy. The construction is based on a per-element deformation gradient and its 
singular value decomposition (SVD), with fallbacks for degenerate or nearly rigid elements.

We start from a registered displacement field $u_i$ defined at each mesh node. 
The reference position of node $i$ is $x_i$, and its current (deformed) position is $X_i=x_i+u_i$. 
Inside a tetrahedron with local vertices $1,2,3,4$, 
we assume the mapping from reference to deformed configuration is affine:

$$
X \approx x_1+F\left(x-x_1\right),
$$
where $F \in \mathbb{R}^{3 \times 3}$ is constant over the element. 
Writing this relation for the three edges attached to vertex 1 gives
$$
X_2-X_1 \approx F\left(x_2-x_1\right), \quad X_3-X_1 \approx F\left(x_3-x_1\right), 
\quad X_4-X_1 \approx F\left(x_4-x_1  \right) .
$$


Collecting these edges into matrices,
$$
D_x=\left[x_2-x_1, x_3-x_1, x_4-x_1\right], \quad D_X=\left[X_2-X_1, X_3-X_1, X_4-X_1\right],
$$

we obtain $D_X \approx F D_{\boldsymbol{x}}$, and 
provided the tetrahedron is non-degenerate (so $D_{\boldsymbol{x}}$ is invertible), 
we estimate the deformation gradient as

$$
F=D_X D_x^{-1} .
$$


To extract principal directions as deformation axis, we compute the SVD of the deformation gradient,

$$
F=U \Sigma V^{\top}, \quad 
\Sigma=\operatorname{diag}\left(\lambda_1, \lambda_2, \lambda_3\right), \quad 
\lambda_1 \geq \lambda_2 \geq \lambda_3>0 .
$$


The right singular vectors (columns of $V$ ) are orthonormal and 
give the principal stretch directions in the reference configuration. 
We therefore define the anisotropy axes as

$$
e_1=v_1, \quad e_2=v_2, \quad e_3=v_3,
$$

with $v_1, v_2, v_3$ the columns of $V$. 
To enforce a right-handed local frame we check the orientation of the triad and, 
if $\left(e_1 \times e_2\right) \cdot e_3<0$, we swap $e_2$ and $e_3$. 
The singular values $\lambda_1, \lambda_2, \lambda_3$ themselves 
represent the principal stretches along those axes and are also used as indicators of degeneracy.

In practice, the SVD-based construction can become unstable in two situations: 
when elements invert or are extremely compressed, and when they undergo almost pure rigid motion. 
If an element inverts (e.g. $\operatorname{det} F \leq 0$ ) 
or becomes highly anisotropic with $\lambda_2 \ll \lambda_0$, 
the principal directions fluctuate and are no longer physically meaningful. 
In that case we fall back to a displacement-based frame that is more stable under extreme distortion.
 We first compute the mean nodal displacement in the element,
$\bar{u}=\frac{1}{4}\left(u_1+u_2+u_3+u_4\right),$
\newline
which captures the overall trend of motion. If $\|\bar{u}\|$ exceeds a small threshold $\varepsilon$, 
we set the first axis to follow this dominant direction, $e_1=\bar{u} /\|\bar{u}\|$. 
To obtain a second orthogonal direction, we choose a reference edge. 
For example, $r=x_2-x_1$, project out its component along $e_1$, and normalize via
$e_2=\frac{r-\left(r \cdot e_1\right) e_1}{\left\|r-\left(r \cdot e_1\right) e_1\right\|} .$
This guarantees $e_1 \perp e_2$. 
The third axis is then defined by the right-hand rule as $e_3= e_1 \times e_2$. 
This displacement-based frame remains well behaved even when the SVD directions become unreliable.
If the mean displacement is also negligible, $\|\bar{u}\| \leq \varepsilon$, 
we treat the element as essentially stationary and 
simply reuse the anisotropy axes computed at the previous time step or iteration instead of 
inventing a new, noisy orientation.

The second problem is when the element undergoes nearly rigid motion, 
with all principal stretches close to one, 
for example $\left|\lambda_i-1\right|<\varepsilon$ for $i=1,2,3$. 
In that case the deformation gradient contains very little stretching, 
and small numerical differences can cause the SVD directions to 
drift from step to step even though the material has barely deformed. 
To avoid spurious re-orientation, we again keep the previously stored 
axes $\left(e_1, e_2, e_3\right)$ as long as the deformation remains 
within this quasi-rigid tolerance, 
and only recompute them once the singular values deviate significantly from unity.

After this construction, 
each tetrahedron $\mathcal{V}_k$ carries a right-handed orthonormal 
frame $\left(e_1, e_2, e_3\right)$ defined in the reference configuration. 
These anisotropy axes are treated as fixed geometric data when we build the intersection
rays for the volumetric topology and when we later decompose the strain into axial 
and shear components in the quadratic energy model.

\subsubsection{Inverse Mapping}
In our setting we exploit this pseudo‑inverse 
construction to aggregate information from the CT volume onto tetrahedral elements. 
From the CT images we interpolate the Hounsfield unit (HU) values at all mesh vertices, 
and for each tetrahedron $\mathcal{T}_k$ we stack the four nodal HU samples into a vector 
$\mathbf{u}_k$. 
To obtain a single HU value associated with the tetrahedral barycenter, 
we do not attempt to invert the broadcast operator $C[k]$ directly, 
since $C[k]$ is typically rectangular and the 
sampled nodal pattern $\text{HU}_k = \left[
\mathrm{HU} \text { at node } 1,
\mathrm{HU} \text { at node } 2,
\mathrm{HU} \text { at node } 3,
\mathrm{HU} \text { at node } 4
\right]^{\top}$ will not in general 
lie exactly in its column space. 
Instead, we define the tetra‑level HU parameter $h_{\mathcal{T}_k}$ 
as the solution of a small least‑squares problem
\[
h_{\mathcal{T}_k} := \arg\min_{h} \| C[k] h - \text{HU}_k \|_2^2
:= \left(C[k]^{\top} C[k]\right)^{-1} C[k]^{\top} \text{HU}_k,
\]
given $C[k]$ has full column rank. 
But in practive, this operatation's result will beyond the normal HU value range.
So instead, we use the mean value of each tetrahedron's nodal HU values as the barycenter HU value.

\subsection{Simulation: Quadratic SMS Model}
\subsubsection{Element Energy in Axis Form}

For each tet $k$ with reference volume $V_k$ we use the following hyperelastic
energy (one copy per element, but with possibly elementwise parameters
$\alpha_k,\beta_k,\kappa_k$; for clarity we temporarily suppress the $k$ index):
\begin{equation}
U_k(F)
=
V_k\Bigg[
\frac{\alpha}{2}\sum_{\ell=0}^{2}\Bigl(\|F e_\ell\|^2-1\Bigr)^2
+
\frac{\beta}{2}\sum_{\ell<m}\Bigl[\bigl(F e_\ell\bigr)\cdot\bigl(F e_m\bigr)\Bigr]^2
+
\frac{\kappa}{2}\bigl(J-1\bigr)^2
\Bigg],
\label{eq:sms_energy_axis_form}
\end{equation}
where $J:=\det F$ is the Jacobian of the deformation.

Our goal in this section is twofold:
\begin{enumerate}
  \item Derive a \emph{quadratic} (small‑strain) approximation of $U_k$ in terms
  of $\varepsilon$.
  \item Prove this quadratic energy equilibrium equivalent to a function of the nodal
  displacements in a \emph{linear finite element} (FEM), and assemble the
  global stiffness matrix $K$ and right‑hand side $f$ with boundary conditions.
\end{enumerate}

\subsubsection{Small–Strain Expansion up to Quadratic Order}

We linearize about the identity $F=I$ under the assumption of small gradients
$\|H\|\ll 1$. So for the previous right Cauchy–Green tensor $C$, it can be expressed with the small strain tensor $\varepsilon$ as:
\[
C = F^\top F
= (I+H)^\top(I+H) \\
= I + H + H^\top + H^\top H \\
= I + 2\varepsilon + H^\top H.
\]
The first term $2\varepsilon$ is \emph{first order} in $\|H\|$, whereas $H^\top H$
is \emph{second order}. Thus
\[
C - I = 2\varepsilon + O(\|H\|^2).
\]
Here we will drop $H^\top H$ inside the square for the following reason.
\newline
Write generically $a=a_1+a_2$ with $a_1=O(\|H\|)$ and $a_2=O(\|H\|^2)$. Then
\[
a^2 = a_1^2 + 2a_1 a_2 + a_2^2
= O(\|H\|^2) + O(\|H\|^3) + O(\|H\|^4).
\]
When building a \emph{quadratic} energy we retain only the $O(\|H\|^2)$ part
($a_1^2$) and discard the $O(\|H\|^3)$ and $O(\|H\|^4)$ contributions. This is
exactly what we are doing by neglecting $H^\top H$ inside the parentheses.
\newline
Then we can express each term in the energy \eqref{eq:sms_energy_axis_form} one by one: 
\newline
\textbf{For each axis term $\ell$},
\[
\|F e_\ell\|^2 - 1
= e_\ell^\top(C-I)e_\ell \\
= 2\,e_\ell^\top\varepsilon\,e_\ell
  + e_\ell^\top(H^\top H)e_\ell.
\]
Define the axial strain component
$\varepsilon_{\ell\ell} := e_\ell^\top \varepsilon\,e_\ell.$
Inside the square $\big(\|F e_\ell\|^2-1\big)^2$, the $H^\top H$ contribution would
produce only cubic and quartic terms in $\|H\|$; since we want to keep the energy only up
to \emph{second order}, we drop these higher–order contributions and approximate
$\|F e_\ell\|^2-1 \;\approx\; 2\,\varepsilon_{\ell\ell}.$
\newline
\textbf{Similarly, for shearing term $\ell\neq m$},
\[
(F e_\ell)\cdot(F e_m)
= e_\ell^\top C e_m
 = 2\,e_\ell^\top\varepsilon e_m + e_\ell^\top(H^\top H)e_m.
\]
Define the shear strain component
$\varepsilon_{\ell m} := e_\ell^\top\varepsilon\,e_m.$ 
Again, $H^\top H$ only contributes third and higher order terms to the squared
energy, so we approximate
\begin{equation}
(F e_\ell)\cdot(F e_m) \;\approx\; 2\,\varepsilon_{\ell m}.
\end{equation}
\begin{theorem}
For \textbf{Determinant $J=\det F$}, we need $(J-1)^2$ and expressed in second order.
\end{theorem}

\begin{proof}\textit{(matrix log expansion)}:
Using the matrix log,
\begin{align*}
\log\det(I+H)
&= \mathrm{tr}\,\log(I+H) \\
&= \mathrm{tr}\Bigl(H - \tfrac12 H^2 + O(H^3)\Bigr) \\
&= \mathrm{tr} H - \tfrac12\mathrm{tr}(H^2) + O(H^3).
\end{align*}
Exponentiating,
\begin{align*}
\det(I+H)
&= \exp\!\Bigl[\mathrm{tr}H - \tfrac12\mathrm{tr}(H^2) + O(H^3)\Bigr] \\
&= 1 + \mathrm{tr}H
 + \tfrac12\Bigl[(\mathrm{tr}H)^2 - \mathrm{tr}(H^2)\Bigr]
 + O(H^3).
\end{align*}

\end{proof}

Thus
\begin{equation}
J - 1
= \underbrace{\mathrm{tr}H}_{O(H)}
+ \underbrace{\tfrac12\Bigl[(\mathrm{tr}H)^2 - \mathrm{tr}(H^2)\Bigr]}_{O(H^2)}
+ O(H^3).
\end{equation}
Squaring and truncating at $O(H^2)$,
\[
(J-1)^2 = (\mathrm{tr}H)^2 + O(H^3).
\]

Using $\mathrm{tr}\,\varepsilon = \tfrac12\mathrm{tr}(H+H^\top)=\mathrm{tr}H$,
we obtain the small–strain relation
$
(J-1)^2 \approx (\mathrm{tr}\,\varepsilon)^2.
$

Plugging the approximations into \eqref{eq:sms_energy_axis_form} and keeping
only terms up to $O(\|H\|^2)$ yields the strictly quadratic energy density
\begin{equation}
w_{\text{quad}}(\varepsilon)
= 2\alpha\sum_{\ell=0}^2 \varepsilon_{\ell\ell}^2
+ 2\beta\sum_{0\le\ell<m\le2}\varepsilon_{\ell m}^2
+ \frac{\kappa}{2}\bigl(\mathrm{tr}\,\varepsilon\bigr)^2.
\label{eq:w_quad_eps}
\end{equation}
In a linear tetrahedral finite element, $\varepsilon$ is constant inside the
element, so
$
U_k \;\approx\; V_k\,w_{\text{quad}}(\varepsilon_k).
$

\paragraph{Relation to isotropic linear elasticity.}
Classical small‑strain linear elasticity with Lamé parameters
$\mu,\lambda$ has
\[
w_{\text{FEM}}(\varepsilon) = \mu\,\varepsilon:\varepsilon
+ \frac{\lambda}{2}\bigl(\mathrm{tr}\,\varepsilon\bigr)^2
= \mu\sum_i \varepsilon_{ii}^2
+ 2\mu\sum_{i<j}\varepsilon_{ij}^2
+ \frac{\lambda}{2}\bigl(\mathrm{tr}\,\varepsilon\bigr)^2.
\]
Comparing with \eqref{eq:w_quad_eps}, we match coefficients via
$
2\alpha = \mu, 2\beta = 2\mu,\kappa = \lambda,
$
so that
$
\alpha = \frac{\mu}{2},
\beta = \mu,
\kappa = \lambda.
$
In practice, an isotropic material with Young’s modulus $E$ and Poisson ratio
$\nu=0.4$, this becomes $
\mu = \frac{E}{2(1+\nu)},
\lambda = \frac{E\nu}{(1+\nu)(1-2\nu)}.
$

\subsubsection{Broadcast Strain to Nodal Displacements}
Based on previous topology and derivations, 
we now express the strain components to the nodes' displacements.
For each element $k$ with local vertex displacements
$\{u_1,u_2,u_3,u_4\}$, stack them as
$u_e
=
[u_1^x,u_1^y,u_1^z,\;
u_2^x,u_2^y,u_2^z,\;
u_3^x,u_3^y,u_3^z,\;
u_4^x,u_4^y,u_4^z
]^\top
\in\R^{12}. $ So that we can assemble a linear solver to obtain the displacements with:
$$
u^{\top} K u = f^{\top} u.
$$
For a single tetrahedral element $k$ with reference vertices $X_1,X_2,X_3,X_4\in\mathbb{R}^3$
and nodal displacement vectors $u_1,u_2,u_3,u_4\in\mathbb{R}^3$, 
we stack the element degrees of freedom as 
$u_e=[u_1^\top,u_2^\top,u_3^\top,u_4^\top]^\top\in\mathbb{R}^{12}$. 
The material axis is represented by three unit directions 
$e_1,e_2,e_3\in\mathbb{R}^3$ with $\lVert e_\ell\rVert=1$. 
Our goal is to express three approximated strain-related scalar quantities—axial, shear, 
and volumetric (trace)—in a unified linear form scalar equal to $r u_e$, 
which later yields a rank-one decomposition of the element stiffness.

To define directional measurements within the element, 
for each axis $\ell\in{1,2,3}$ we select two reference sampling points 
$p_\ell^{(1)}$ and $p_\ell^{(2)}$ inside the tetrahedron. 
For notational uniformity, we relabel these six points as $p_{2\ell-1}=p_\ell^{(1)}$
and $p_{2\ell}=p_\ell^{(2)}$. 
We use the previously defined barycentric coefficient matrix $C^k_{ij}$,
so that each sampling point $p_j$ is expressed by the reference vertices as 
$p_j=\sum_{i=1}^4 C^k_{ij}X_i$. 
Under standard linear interpolation of displacement within the tetrahedron, 
the displacement at that point is $u(p_j)=\sum_{i=1}^4 C^k_{ij}u_i$. 
It allows every directional difference of 
displacement to be written as a fixed linear combination of nodal unknowns.

For axial item along axis $\ell$, we define the per-vertex difference coefficients 
$s^k_{\ell i}=C^k_{i,2\ell}-C^k_{i,2\ell-1}$ for $i=1,2,3,4$. 
The displacement difference across the sampled segment on axis $\ell$ is then 
$\Delta u_\ell=u(p_{2\ell})-u(p_{2\ell-1})=\sum_{i=1}^4 s^k_{\ell i}u_i$. 
Let the reference segment length be $\ell_\ell^0=\lVert p_{2\ell}-p_{2\ell-1}\rVert$. 
Under the small-strain approximation, 
the axial strain component along $e_\ell$ is modeled by the directional derivative 
projected onto the same axis, 
$\varepsilon_{\ell\ell}\approx (e_\ell^\top\Delta u_\ell)/\ell_\ell^0$. 
Expanding in nodal unknowns gives 
$\varepsilon_{\ell\ell}=\sum_{i=1}^4 (s^k_{\ell i}/\ell_\ell^0)e_\ell^\top u_i$. 
This defines a row vector $r_{\ell\ell}\in\mathbb{R}^{1\times 12}$ 
by setting the $i$-th $(1\times 3)$ block to 
$r_{\ell\ell}^{(i)}=(s^k_{\ell i}/\ell_\ell^0)e_\ell^\top$, 
and concatenating across vertices. With this construction, each axial component is written as 
$\varepsilon_{\ell\ell}=r_{\ell\ell}u_e$ for $\ell=1,2,3$.

For shear, we represent the off-diagonal small-strain components in the axis basis. 
In the form of standard strain tensor $\varepsilon=\tfrac12(\nabla u + (\nabla u)^\top)$, 
the shear component associated with axes 
$\ell\neq m$ can be written as 
$\varepsilon_{\ell m}=\tfrac12\big(e_\ell^\top(\nabla u)e_m + e_m^\top(\nabla u)e_\ell\big)$. 
We approximate the directional derivatives using the same two-point differences: 
$e_m^\top(\nabla u)e_\ell\approx e_m^\top\Delta u_\ell/\ell_\ell^0$
and $e_\ell^\top(\nabla u)e_m\approx e_\ell^\top\Delta u_m/\ell_m^0$. 
Substituting these approximations yields 
$\varepsilon_{\ell m}\approx \tfrac12\big(e_m^\top\Delta u_\ell/\ell_\ell^0 + e_\ell^\top\Delta u_m/\ell_m^0\big)$. 
Using $\Delta u_\ell=\sum_i s^k_{\ell i}u_i$ and 
$\Delta u_m=\sum_i s^k_{m i}u_i$, the contribution of vertex $i$
becomes a $1\times 3$ block $r_{\ell m}^{(i)}=\tfrac12\big((s^k_{\ell i}/\ell_\ell^0)e_m^\top + (s^k_{m i}/\ell_m^0)e_\ell^\top\big)$. 
Concatenating these blocks defines $r_{\ell m}\in\mathbb{R}^{1\times 12}$ 
such that $\varepsilon_{\ell m}=r_{\ell m}u_e$. 
Since $\varepsilon_{\ell m}=\varepsilon_{m\ell}$, we can enumerate pairs within $1\le \ell<m\le 3$.

For the volumetric (trace) component, 
we use the fact that under small deformation the relative volume change of a tetrahedron 
equals the trace of the infinitesimal strain to first order. 
The reference volume of element $k$ can be written as 
$V_k=\tfrac16 (X_2-X_1)\cdot((X_3-X_1)\times(X_4-X_1))$. 
The first-order volume variation takes the linear form $\Delta V_k=\sum_{i=1}^4 g_i\cdot u_i$ 
with constant vectors $g_i\in\mathbb{R}^3$ determined solely by the reference geometry:
$
g_1=\frac{(X_2-X_3)\times (X_4-X_3)}{6},
g_2=\frac{(X_3-X_1)\times (X_4-X_1)}{6},
g_3=\frac{(X_1-X_2)\times (X_4-X_2)}{6},
g_4=\frac{(X_1-X_3)\times (X_2-X_3)}{6}.
$

Then the relative volume change becomes $\Delta V_k/V_k=\sum_{i=1}^4 (g_i/V_k)\cdot u_i$. 
Defining $r_{\mathrm{vol}}^{(i)}=(g_i/V_k)^\top\in\mathbb{R}^{1\times 3}$ and 
concatenating across vertices gives $r_{\mathrm{vol}}\in\mathbb{R}^{1\times 12}$ 
such that $\Delta V_k/V_k=r_{\mathrm{vol}}u_e$. 
In the small-strain regime, we then use the classical first-order identity 
$\operatorname{tr}\varepsilon\approx \Delta V_k/V_k$, 
hence $\operatorname{tr}\varepsilon\approx r_{\mathrm{vol}}u_e$.

With these linear scalar forms, 
we define a quadratic element energy that penalizes axial, shear, and volumetric deformation modes. 
Using the convention that each measured scalar takes the form $(r u_e)$, 
the element energy is written as a weighted sum of squared scalars:
$$
U_k(u_e)=\sum_{\ell=1}^3 (2\alpha V_k)(r_{\ell\ell}u_e)^2
+\sum_{1\le \ell<m\le 3} (2\beta V_k)(r_{\ell m}u_e)^2
+\left(\frac{\kappa}{2}V_k\right)(r_{\mathrm{vol}}u_e)^2.
$$
Using the identity $(r u_e)^2 = u_e^\top(r^\top r)u_e$ and 
matching the standard quadratic form $U_k(u_e)=\tfrac12 u_e^\top K_k u_e$, 
the element stiffness admits a sum of rank-one outer products:
\begin{equation}
\boxed{
  K_k
=\sum_{\ell=1}^3 (4\alpha V_k)r_{\ell\ell}^\top r_{\ell\ell}
+\sum_{1\le \ell<m\le 3} (4\beta V_k)r_{\ell m}^\top r_{\ell m}
+(\kappa V_k)r_{\mathrm{vol}}^\top r_{\mathrm{vol}}.
}
\end{equation}
This decomposition makes the assembly and interpretation transparent: 
each axial/shear/volumetric measurement contributes a positive semidefinite rank-one update to $K_k$, 
scaled by the element volume and the corresponding material weights.


\subsubsection{Static Equilibrium with Boundary Conditions}

The global equilibrium on the free DOFs is
\begin{equation}
K_{FF}u_F = f_F,
\end{equation}
where $u_F$ collects the free components of the displacement and $f_F$ the
corresponding components of the net \emph{external} force. For this quadratic
model the internal force is $f_{\mathrm{int}} = Ku$, so the RHS $f_F$ contains
only body forces and tractions.

\paragraph{Body forces (gravity).}
In $(\mathrm{kg},\mathrm{mm},\mathrm{s})$ units, set
$
g = (0,-9810,0)^\top\;\mathrm{mm/s^2}.
$
Given nodal masses $m_i$ (obtained in preprocessing from the element volumes and
density), we add to each free node $i$:
$
f_F^{(i)} \mathrel{+}= m_i\,g.
$

\paragraph{Dirichlet DOFs.}
Dirichlet boundary conditions (e.g. prescribed displacements from image
registration) are handled by \emph{removing} the constrained DOFs from the
system. This involves two steps: Fixing the boundary nodal positions directly as $X_i = x_i + u^{\mathrm{bc}}_i$
, then building a compressed DOF map that omits these constrained entries.
In this setup we do \emph{not} need to add correction terms of the form
$-K_{FD}u_D$ to the RHS, because the system is formed directly on the free DOFs.

\subsection{Inverse Problem(new)}
The overall inverse problem is to estimate a spatially varying stiffness 
field $\left\{\alpha_k\right\}_{k=1}^M$ from observed displacements $u_{\text {obs }}$ 
obtained via image registration. The remaining SMS coefficients are parameterized 
by $\alpha_k$ through constitutive relations with a fixed Poisson ratio $\nu$; 
for example, $\beta_k=2 \alpha_k$ and $\kappa_k=\frac{4 \nu}{1-2 \nu} \alpha_k$ 
with $\nu=0.4$. Under this parameterization, the assembled global stiffness matrix 
is denoted by $K(\alpha)$, and the simulated displacement field $u^{\star}(\alpha)$ is 
defined implicitly as the solution of the quasi-static force balance

$$
K(\alpha) u^{\star}=b,
$$

where $b$ collects external forces and the contributions induced by boundary conditions. 
We then seek $\alpha$ such that the equilibrium displacement matches the observed motion 
while remaining spatially regular. The constrained inverse problem is written as

$$
\min _{\alpha, u} \mathcal{L}_{\text {data }}(u)+\omega_1 R_u(u)+\omega_2 R_\alpha(\alpha) \quad \text { s.t. } \quad K(\alpha) u=b,
$$

where $\mathcal{L}_{\text {data }}$ measures the simulation-observation misfit, 
$R_u$ regularizes the deformation, and $R_\alpha$ enforces spatial 
coherence of the stiffness field. The weights $\omega_1, \omega_2$ balance the influence 
of each regularizer.
Enforcing equilibrium through $u^{\star}(\alpha)$, 
we consider the reduced objective 
$\mathcal{J}(\alpha)=\mathcal{L}\left(u^{\star}(\alpha), \alpha\right)$. 
We use a normalized (relative) quadratic data term

$$
\mathcal{L}_{\mathrm{data}}\left(u^{\star}\right)=\frac{\left\|u^{\star}-
u_{\mathrm{obs}}\right\|_2^2}{c_{\mathrm{rel}}}, \quad c_{\mathrm{rel}}=
\left\|u_{\mathrm{obs}}\right\|_2^2+\left(\epsilon_{\mathrm{rel}}\left\|u_{\mathrm{obs}}\right\|_2\right)^2,
$$

So the full objective is

$$
\mathcal{L}\left(u^{\star}, \alpha\right)=\mathcal{L}_{\text {data }}\left(u^{\star}\right)+\omega_1 R_u\left(u^{\star}\right)+\omega_2 R_\alpha(\alpha) .
$$


Regularization terms with elementwise gradients
To regularize the displacement field, 
we penalize the elementwise displacement gradient $\nabla_{T_k} u^{\star}$, 
which is constant on each linear tetrahedron $T_k$. Using a Charbonnier (smoothed TV) form, 
we define

$$
R_u\left(u^{\star}\right)=\sum_{k=1}^M V_k \sqrt{\left\|\nabla_{T_k} u^{\star}\right\|_F^2+\varepsilon^2},
$$

where $V_k$ is the reference volume of $T_k,\|\cdot\|_F$ is the Frobenius norm.
For the stiffness field, we impose spatial smoothness via 
an analogous Charbonnier-type penalty on the FE gradient 
$\nabla_{T_k} \alpha$. Writing $\bar{\alpha}_k$ for each tetra's barycentric average of 
$\alpha$ over $T_k$, we use

$$
R_\alpha(\alpha)=\sum_{k=1}^M V_k \sqrt{\frac{\left\|\nabla_{T_k} \alpha\right\|_2^2}{\left(\bar{\alpha}_k+\frac{1}{2} \varepsilon_{\mathrm{div}}\right)^2}+\varepsilon_{\mathrm{reg}}^2},
$$

where $\varepsilon_{\text {div }}>0$ prevents division by very small 
$\bar{\alpha}_k$ and $\varepsilon_{\text {reg }}>0$ provides Charbonnier smoothing. 
This construction encourages spatial coherence while remaining robust to 
sharp transitions (e.g., across heterogeneous regions).
\newline
Because $u^{\star}(\alpha)$ is defined implicitly by the equilibrium equation, 
differentiating $\mathcal{J}(\alpha)$ directly would require differentiating 
the solution map $\alpha \mapsto u^{\star}(\alpha)$. 
Instead, we apply the adjoint-state method. First, the derivative of the data term with 
respect to $u^{\star}$ is

$$
\frac{\partial \mathcal{L}_{\text {data }}}{\partial u^{\star}}=\frac{2}{c_{\mathrm{rel}}}\left(u^{\star}-u_{\mathrm{obs}}\right),
$$

and the total partial derivative of $\mathcal{L}$ with respect to $u^{\star}$ is

$$
\frac{\partial \mathcal{L}}{\partial u^{\star}}=\frac{2}{c_{\mathrm{rel}}}\left(u^{\star}-u_{\mathrm{obs}}\right)+\omega_1 \frac{\partial R_u}{\partial u^{\star}} .
$$


We define the Lagrangian

$$
\Phi\left(u^{\star}, \alpha, \lambda\right)=\mathcal{L}_{\text {data }}\left(u^{\star}\right)+\omega_1 R_u\left(u^{\star}\right)+\omega_2 R_\alpha(\alpha)-\lambda^{\top}\left(K(\alpha) u^{\star}-b\right),
$$

where $\lambda$ is the adjoint vector.
\newline 
The adjoint equation w.r.t. $u^{\star}$ is:

$$
K(\alpha)^{\top} \lambda=\frac{2}{c_{\mathrm{rel}}}\left(u^{\star}-u_{\mathrm{obs}}\right)+\omega_1 \frac{\partial R_u}{\partial u^{\star}} .
$$


Stationarity with respect to $\lambda$ recovers the primal equilibrium constraint 
$K(\alpha) u^{\star}=b$. 
Finally, stationarity with respect to $\alpha$ provides the reduced gradient in a form 
that avoids differentiating $u^{\star}(\alpha)$ :

$$
\frac{\partial \mathcal{J}}{\partial \alpha}=-\lambda^{\top}\left(\frac{\partial K}{\partial \alpha} u^{\star}\right)+\omega_2 \frac{\partial R_\alpha}{\partial \alpha} .
$$


This formulation requires only one forward solve for $u^{\star}$ 
and one adjoint solve for $\lambda$ per outer iteration, 
after which the stiffness gradient follows from elementwise sensitivity 
contributions $(\partial K / \partial \alpha) u^{\star}$ 
and the explicit regularization gradient $\partial R_\alpha / \partial \alpha$.

\subsection{Inverse in appendix}
\subsubsection{$\partial R/ \partial u$:}
We consider a tetrahedral mesh with elements $T_k(k=1, \ldots, M)$ and volumes $V_k$. 
The forward solve produces the displacement on free DOFs, 
$u_{\text {sim }} \in \mathbb{R}^{3 N_f}$; for brevity we write $u:=u_{\text {sim }}$. 
On each linear tetrahedron $T_k$, 
the shape-function gradients $\nabla N_a^{(k)} \in \mathbb{R}^3$ are constant, 
so the elementwise displacement gradient is constant and defined by

$$
\nabla_{T_k} u=\sum_{i=1}^4 u_i \otimes \nabla N_i^{(k)} \in \mathbb{R}^{3 \times 3},
$$

where $u_i \in \mathbb{R}^3$ are the nodal displacement vectors 
of the four vertices of $T_k$. We regularize this gradient using an isotropic TV form 
smoothed by a Charbonnier function,

$$
R(u)=\sum_{k=1}^M V_k \sqrt{\left\|\nabla_{T_k} u\right\|_F^2+\varepsilon^2},
$$
To compute its gradient with respect to the global unknowns, we use the first variation: 
for any admissible perturbation $\delta u$, the induced first-order change $\delta R$ 
is the differential of $R$ at $u$ applied to $\delta u$, 
and by definition of the gradient in Euclidean coordinates,

$$
\delta R=d R_u(\delta u)=\left(\frac{\partial R}{\partial u}\right)^{\top} \delta u .
$$
To express this differential in a form that exposes $\partial R / \partial u$, 
we introduce a sparse mapping from global displacement DOFs to stacked elementwise gradients. 
For each element $T_k$, define the local displacement vector 
$u_e=\left[u_1^{\top}, u_2^{\top}, u_3^{\top}, u_4^{\top}\right]^{\top} \in \mathbb{R}^{12}$ 
and the gradient matrix $B_k= \left[\nabla N_1^{(k)} \nabla N_2^{(k)} \nabla N_3^{(k)} \nabla N_4^{(k)}\right] \in \mathbb{R}^{3 \times 4}$. 
Let

$$
\tilde{u_k}=\left[u_1 u_2 u_3 u_4\right] \in \mathbb{R}^{3 \times 4}, \quad \text { so that } \quad \nabla_{T_k} u=\tilde{u_k} B_k^{\top} \in \mathbb{R}^{3 \times 3} .
$$


Vectorizing the $3 \times 3$ gradient (stacking columns) yields a 9-vector, 
and using vec $\left(\tilde{u_k} B_k^{\top}\right)=\left(B_k \otimes\right. 
\left.I_3\right) \operatorname{vec}\left(\tilde{u_k}\right)$, 
we define the element operator $G_k:=B_k \otimes I_3 \in \mathbb{R}^{9 \times 12}$ 
such that
$$
\operatorname{vec}\left(\nabla_{T_k} u\right)=G_k u_e .
$$
Let $P_k \in \mathbb{R}^{12 \times 3 N_f}$ be the element-to-global gather matrix 
that extracts the 12 local DOFs from the global vector, 
so $u_e=P_k u$ and $\delta u_e=P_k \delta u$. 
Stacking all element contributions (9 rows per element) defines the global sparse operator
$$
G=\left[\begin{array}{c}
G_1 P_1 \\
\vdots \\
G_M P_M
\end{array}\right] \in \mathbb{R}^{9 M \times 3 N_f}, \quad G u=\left[\begin{array}{c}
\operatorname{vec}\left(\nabla_{T_1} u\right) \\
\vdots \\
\operatorname{vec}\left(\nabla_{T_M} u\right)
\end{array}\right] .
$$
With $S_k:=\nabla_{T_k} u$, write the per-element contribution as 
$R_k(u)=\sqrt{\left\|S_k\right\|_F^2+\varepsilon^2}=\sqrt{\operatorname{tr}\left(S_k^{\top} 
S_k\right)+\varepsilon^2 \text {. }}$ 
Taking the first variation and using the chain rule gives
$$
\delta R_k=V_k \frac{\operatorname{tr}\left(S_k^{\top} \delta S_k\right)}
{\sqrt{\left\|S_k\right\|_F^2+\varepsilon^2}}
$$
Since $\delta S_k=\nabla_{T_k} \delta u$ and 
$\operatorname{tr}\left(A^{\top} B\right)=\operatorname{vec}(A)^{\top} 
\operatorname{vec}(B)$, 
together with $\operatorname{vec}\left(\delta S_k\right)=G_k \delta u_e$, we obtain

$$
\delta R_k=\frac{V_k}{\sqrt{\left\|S_k\right\|_F^2+\varepsilon^2}} 
\operatorname{vec}\left(S_k\right)^{\top} G_k \delta u_e .
$$


Substituting $\delta u_e=P_k \delta u$ and summing over all elements yields

$$
\delta R=\sum_{k=1}^M \frac{V_k}{\sqrt{\left\|S_k\right\|_F^2+\varepsilon^2}} 
\operatorname{vec}\left(S_k\right)^{\top} G_k P_k \delta u=
\left(\sum_{k=1}^M P_k^{\top} G_k^{\top} 
\frac{V_k}{\sqrt{\left\|S_k\right\|_F^2+\varepsilon^2}} 
\operatorname{vec}\left(S_k\right)\right)^{\top} \delta u .
$$


Comparing with $\delta R=d R_u(\delta u)=(\partial R / \partial u)^{\top} \delta u$ identifies

$$
\frac{\partial R}{\partial u}=\sum_{k=1}^M P_k^{\top} G_k^{\top} 
\frac{V_k}{\sqrt{\left\|S_k\right\|_F^2+\varepsilon^2}} \operatorname{vec}\left(S_k\right) .
$$
\subsubsection{$\partial R / \partial \alpha$:} 
Usually, a continuum TV-type regularization on a scalar parameter $\mu$ is written as

$$
R(\mu)=\int_{\Omega} \sqrt{\frac{\|\nabla \mu\|^2}
{\left(\mu+\varepsilon_{\text {div }}\right)^2}+\varepsilon_{\text {reg }}^2} \mathrm{~d} V .
$$


This form penalizes spatial oscillations through $\|\nabla \mu\|$ 
while normalizing by $\mu+\varepsilon_{\text {div }}$ to avoid scale bias 
and to prevent division by zero when $\mu$ is small. 
The Charbonnier constant $\varepsilon_{\text {reg }}$ 
smooths the absolute value behavior so that the functional remains differentiable 
and numerically stable.

For our discretization, we apply the same structure to the nodal field $\alpha$. 
Using linear tetrahedral finite elements, 
$\alpha$ is piecewise-linear and therefore its gradient is constant within each tetrahedron.
Approximating the volume integral by one-point (barycentric) quadrature 
leads to a simple sum of element contributions: 
each tetrahedron contributes its volume times the integrand evaluated at the barycenter. 
Concretely,
$
R(\alpha) \approx \sum_{k=1}^M V_k \sqrt{\frac{\left\|\nabla_{T_k} \alpha\right\|^2}{\left(\bar{\alpha}_k+\varepsilon_{\mathrm{div}}\right)^2}+\varepsilon_{\mathrm{reg}}^2} .
$
On each tetrahedron $T_k$ (volume $V_k$ ), the gradient is constant:
$\nabla_{T_k} \alpha=\sum_{i=1}^4 \alpha_i \nabla N_i^{(k)},$
and evaluating $\alpha$ at the barycenter gives the element average
$\bar{\alpha}_k=\frac{1}{4} \sum_{i=1}^4 \alpha_i .$
\newline
We now derive the discrete gradient of this regularizer. 
Define the per-element contribution
$$
R_k(\alpha):=V_k \sqrt{\frac{\left\|\nabla_{T_k} \alpha\right\|^2}{\left(\bar{\alpha}_k+\varepsilon_{\mathrm{div}}\right)^2}+\varepsilon_{\mathrm{reg}}^2}
$$
Our goal is to differentiate $R_k$ with respect to the four nodal values on $T_k$. 
To streamline the chain rule, introduce the intermediate quantity
$$
A_k:=\frac{\left\|\nabla_{T_k} \alpha\right\|^2}{\left(\bar{\alpha}_k+\varepsilon_{\mathrm{div}}\right)^2}
$$
Then $R_k(\alpha)=V_k \sqrt{A_k+\varepsilon_{\text {reg }}^2}$, 
and the first variation follows directly from the derivative of the square root:
$$
\delta R_k=V_k \cdot \frac{1}{2 \sqrt{A_k+\varepsilon_{\mathrm{reg}}^2}} \delta A_k .
$$
The remaining step is to compute $\delta A_k$, 
which depends on both the numerator $\left\|\nabla_{T_k} \alpha\right\|^2$ 
and the denominator $\left(\bar{\alpha}_k+\varepsilon_{\text {div }}\right)^2$. 
Applying the product rule gives
$$
\delta A_k=\frac{2 \nabla_{T_k} \alpha \cdot \nabla_{T_k}(\delta \alpha)}{\left(\bar{\alpha}_k+\varepsilon_{\mathrm{div}}\right)^2}-\frac{2\left\|\nabla_{T_k} \alpha\right\|^2}{\left(\bar{\alpha}_k+\varepsilon_{\mathrm{div}}\right)^3} \delta \bar{\alpha}_k .
$$
Substitute $
\nabla_{T_k}(\delta \alpha)=\sum_{i=1}^4 \delta \alpha_i \nabla N_i^{(k)},  
\delta \bar{\alpha}_k=\frac{1}{4} \sum_{i=1}^4 \delta \alpha_i
$ into $\delta R_k$ and grouping by
$\delta\alpha_a$:
$$
\delta R_k=\sum_{i=1}^4\left[V_k\left(\frac{\nabla_{T_k} 
\alpha \cdot \nabla N_i^{(k)}}{\left(\bar{\alpha}_k+
\varepsilon_{\text {div }}\right)^2 \sqrt{\frac{\left\|\nabla_{T_k} 
\alpha\right\|^2}{\left(\bar{\alpha}_k+\varepsilon_{\text {div }}\right)^2}+
\varepsilon_{\text {reg }}^2}}-\frac{\left\|\nabla_{T_k} 
\alpha\right\|^2}{\left(\bar{\alpha}_k+\varepsilon_{\text {div }}\right)^3 
\sqrt{\frac{\left\|\nabla_{T_k} \alpha\right\|^2}
{\left(\bar{\alpha}_k+\varepsilon_{\text {div }}\right)^2}+\varepsilon_{\text {reg }}^2}} 
\cdot \frac{1}{4}\right)\right] \delta \alpha_i .
$$
From this expression we can obtain the element gradient vector (four entries, one per node). 
Writing the vector $\alpha_e^{(k)}=\left[\alpha_1, \alpha_2, \alpha_3, \alpha_4\right]^{\top}$, 
the elementwise derivative is

$$
\frac{\partial R_k}{\partial \alpha_e^{(k)}}=V_k\left(\frac{\left[\begin{array}{l}
\nabla_{T_k} \alpha \cdot \nabla N_1^{(k)} \\
\nabla_{T_k} \alpha \cdot \nabla N_2^{(k)} \\
\nabla_{T_k} \alpha \cdot \nabla N_3^{(k)} \\
\nabla_{T_k} \alpha \cdot \nabla N_4^{(k)}
\end{array}\right]}{\left(\bar{\alpha}_k+\varepsilon_{\text {div }}\right)^2 
\sqrt{\frac{\left\|\nabla_{T_k} \alpha\right\|^2}{\left(\bar{\alpha}_k+
\varepsilon_{\text {div }}\right)^2}+\varepsilon_{\text {reg }}^2}}-
\frac{\left\|\nabla_{T_k} \alpha\right\|^2}{\left(\bar{\alpha}_k
+\varepsilon_{\text {div }}\right)^3 \sqrt{\frac{\left\|\nabla_{T_k} \alpha\right\|^2}
{\left(\bar{\alpha}_k+\varepsilon_{\text {div }}\right)^2}+\varepsilon_{\text {reg }}^2}} 
\frac{1}{4}\right) .$$
\newline
Similary, the global gradient $\partial R / \partial \alpha$ is obtained by scattering 
the four entries of $\partial R_k / \partial \alpha_e^{(k)}$ 
to the corresponding global nodal indices and summing over all tetrahedra.

\subsection{Integrate with GCN}

Our goal is to map per--tetra HU to stiffness through a two--layer GCN that respects tetra adjacency. The full pipeline is summarized below; all formulas are reproduced for completeness and adapted to paragraph form.

\paragraph{Adjacency for tetrahedra $\mathcal T_k$.}
For each tetrahedron $\mathcal T_k$, build the neighbor set $\mathcal N(k)=\{i_1,\dots,i_{j_k}\}$ of tets sharing a face. Since connectivity is fixed, compute adjacency once during preprocessing (e.g., while packing HU) and save it (CSR edge list such as \texttt{tet\_neighbor\_indices}, \texttt{tet\_neighbor\_offsets}). A vectorized CPU procedure: generate all four faces $(i_1,i_2,i_3)$, $(i_1,i_2,i_4)$, $(i_1,i_3,i_4)$, $(i_2,i_3,i_4)$ for each tet, sort each triple, attach tet IDs, sort the $(4M\times 3)$ face array lexicographically with the same permutation on owners, then scan consecutive faces; pairs with identical triples yield undirected edges, singletons are boundary faces. This C–backed sorting/grouping is fast and avoids Python loops. The resulting structure is either $\mathcal N(k)$ or a symmetric edge list $E=\{(k,\ell)\}$.

\paragraph{GCN architecture (sum aggregation, no averaging).}
Input is scalar HU $h_k$, normalized as $\tilde h_k^{(0)} = \frac{h_k - \mu_{\mathrm{HU}}}{\sigma_{\mathrm{HU}}}$. First layer:
\[
\tilde{h}^{(1)}_k
= \sigma\!\left(
b^{(1)}+\sum_{j \in \mathcal{N}(k)} \tilde h_j^{(0)} W_{\text{nei}}^{(1)}
+ \tilde h_k^{(0)} W_{\text{self}}^{(1)}
  \right),
\]
with $W_{\text{nei}}^{(1)},W_{\text{self}}^{(1)}\!\in\!\mathbb R^{1\times F_1}$ and $b^{(1)}\!\in\!\mathbb R^{F_1}$. Second layer:
\[
s_k
= b^{(2)}
+ \sum_{j \in \mathcal N(k)} \langle \tilde h^{(1)}_j, W_{\text{nei}}^{(2)} \rangle
+ \langle \tilde h^{(1)}_k, W_{\text{self}}^{(2)} \rangle,
\]
where $W_{\text{nei}}^{(2)},W_{\text{self}}^{(2)}\!\in\!\mathbb R^{F_1}$ and $b^{(2)}\!\in\!\mathbb R$. Clamp in log space and exponentiate:
\[
\hat s_k = \operatorname{clip}(s_k,\log\alpha_{\min},\log\alpha_{\max}),\qquad
\alpha_k = \exp(\hat s_k),
\]
yielding the two--layer map $\tilde h_k^{(0)} \to \tilde h_k^{(1)} \to s_k \to \alpha_k$.

\paragraph{Training data per case and time.}
For each CasePack $c$ with $M_c$ tets: a T00 mesh (points $\mathbf x^{(c)}$, connectivity $\mathcal T_k^{(c)}$) and adjacency $\mathcal N^{(c)}(k)$; HU fields \texttt{hu\_tetra\_steps} $(S_c,M_c,1)$ and time‐mean \texttt{hu\_tetra\_mean} $(M_c,1)$; per–timestamp NPZs (for $t=1,\dots,S_c$) containing geometry, $r_{\text{axis}},r_{\text{shear}},r_{\text{vol}}$, boundary data, and observed displacements $u^{(c,t)}_{\text{obs}}$ on the fixed T00 mesh. One HU scalar per tet is taken as $h_k^{(c)}=\text{hu\_tetra\_mean}[k,0]$; tissue density is assumed time–invariant while deformation and BCs change with $t$.

\paragraph{GCN forward pass (per case).}
Form $\mathbf h^{(c)}$ and normalize:
\[
\tilde h_k^{(0,c)} = \frac{h_k^{(c)} - \mu^{(c)}}{\sigma^{(c)} + \varepsilon},\quad
\mu^{(c)}=\tfrac{1}{M_c}\sum_k h_k^{(c)},\quad
\sigma^{(c)}=\sqrt{\tfrac{1}{M_c}\sum_k (h_k^{(c)}-\mu^{(c)})^2}.
\]
Using $\mathcal N^{(c)}$, the two layers give
\[
\tilde h^{(1,c)}_k
= \sigma\!\left(
b^{(1)}
+ \sum_{j \in \mathcal N^{(c)}(k)} \tilde h_j^{(0,c)} W_{\text{nei}}^{(1)}
+ \tilde h_k^{(0,c)} W_{\text{self}}^{(1)}
  \right),
\]
\[
s_k^{(c)}
= b^{(2)}
+ \sum_{j \in \mathcal N^{(c)}(k)} \langle \tilde h_j^{(1,c)}, W_{\text{nei}}^{(2)} \rangle
+ \langle \tilde h_k^{(1,c)}, W_{\text{self}}^{(2)} \rangle,
\]
then clamping and exponentiation
\[
\hat s_k^{(c)} = \operatorname{clip}\!\bigl(s_k^{(c)}, \log\alpha_{\min}, \log\alpha_{\max}\bigr),\quad
\alpha_k^{(c)} = \exp(\hat s_k^{(c)}),
\]
produce a single stiffness field per case, shared over time: $\alpha_k^{(c,t)} \equiv \alpha_k^{(c)}$.

\paragraph{Per–timestamp simulation.}
For each time $t$, reuse $\hat s^{(c)}$ as the per–tet log parameter in \texttt{SMSLayer\_{$c,t$}} with $\theta=0$, $\delta^{(c,t)}=\hat s^{(c)}$:
\[
L_{c,t} = L\bigl(\theta=0,\ \delta^{(c,t)}=\hat s^{(c)},\ \text{sim}_{c,t},\ u^{(c,t)}_{\text{obs}}\bigr),
\]
where $\alpha_k^{(c,t)}=\exp(\operatorname{clip}(\theta+\delta_k^{(c,t)},\log\alpha_{\min},\log\alpha_{\max}))$. Shape gradients, barycenters, and SMS rows differ by timestamp; $\alpha$ is shared. The loss combines a data misfit between $u^{(c,t)}_{\text{sim}}$ and $u^{(c,t)}_{\text{obs}}$, a displacement TV term on $\nabla u^{(c,t)}_{\text{sim}}$, and a log–TV term on $\log\alpha^{(c)}$.

\paragraph{Case‐level objective and optimization.}
Average timestamp losses for case $c$:
\[
L_c(\Theta) = \frac{1}{S_c}\sum_{t=1}^{S_c} L_{c,t}(\Theta),
\]
then optimize
\[
\mathcal L(\Theta)=\frac{1}{C}\sum_{c=1}^{C} L_c(\Theta).
\]
For each case, run the GCN once to obtain $\hat s^{(c)}$, evaluate all timestamps, average to $L_c$, backpropagate, and take one optimizer step (Adam). This uses all timestamps as a mini–batch and enforces a single stiffness field per subject.

\paragraph{Learnable linear HU$\to$log‐stiffness baseline.}
HU ranges about $[-972.63, 202.33]$. Introduce a global linear map $s^{\mathrm{lin}}_k = a + b\,h_k^{(c)}$ with trainable $a,b\in\mathbb R$, shared across tets and cases, capturing a monotone HU$\to$stiffness trend. The GCN learns a residual $r_k^{(c)}=\text{GCN}(h^{(c)},\mathcal N^{(c)})_k$ and combines
\[
s_k^{(c)} = s^{\mathrm{lin}}_k + r_k^{(c)}.
\]
Clamp and exponentiate as above:
\[
\hat s_k^{(c)} = \operatorname{clip}(s_k^{(c)},\log\alpha_{\min},\log\alpha_{\max}),\quad
\alpha_k^{(c)} = \exp(\hat s_k^{(c)}).
\]
The SMS layer uses $\hat s^{(c)}$ to assemble and compute losses; gradients propagate through both $(a,b)$ and GCN weights.

\paragraph{Initialization of the linear map.}
Let $h_{\min},h_{\max}$ be global min/max HU (e.g., $-973, 202$) and $L_{\min}=\log\alpha_{\min}$, $L_{\max}=\log\alpha_{\max}$ (e.g., 500 and $10^4$ Pa). Initialize
\[
b^{(0)} = \frac{L_{\max}-L_{\min}}{h_{\max}-h_{\min}},\qquad
a^{(0)} = L_{\min} - b^{(0)} h_{\min},
\]
so $s^{\mathrm{lin}}(h_{\min})\approx L_{\min}$, $s^{\mathrm{lin}}(h_{\max})\approx L_{\max}$. Initialize the GCN with small weights and zero biases so $r_k^{(c)}\!\approx\!0$ initially and $s_k^{(c)}\!\approx\!s^{\mathrm{lin}}_k$.

\paragraph{Time‐varying stiffness (future extension).}
The current model enforces $\alpha_k^{(c,t)}\equiv\alpha_k^{(c)}$ for all $t$, matching the physical view of tissue stiffness and avoiding under–constrained learning with only ten cases. A time‐dependent extension could use time‐dependent HU (e.g., \texttt{hu\_tetra\_steps}), respiratory phase, or a graph‐conv RNN with hidden state $z_k^{(c,t)}$ to let $\alpha_k^{(c,t)}$ evolve, while keeping the same per–case timestamp loss aggregation and backpropagation through time.

\section{Experiments}
\subsection{preprocessing}
\subsubsection{Workflow}
pymlash mesh generation 
for each adjacency ct image, we obtian the registration. 

\subsubsection{Small Strain Verification}
Our model has an assumption of small strain. We verify this assumption by computing the maximum strain in each simulation. The maximum strain is computed as the maximum singular value of the deformation gradient tensor F minus 1.

\subsection{Implementation Details}
\subsubsection{Sparse Assembly and Solve in GPU}
For each element $k$, we precompute the measurement row vectors inside each tetrahedron:
\begin{enumerate}
  \item Precompute the six axis–intersection points (or other chosen points)
  $p_\ell^{(1)},p_\ell^{(2)}$ in the reference configuration and their barycentric
  coordinates $C_k[a,\text{pt}]$.
  \item Form
  \[
  s_\ell[a] = C_k[a,p^{(2)}_\ell] - C_k[a,p^{(1)}_\ell],\qquad
  \ell^0_\ell = \bigl\|p_\ell^{(2)}-p_\ell^{(1)}\bigr\|.
  \]
  \item Build the three axial measurement rows:
  \[
  r_{\ell\ell}^{(a)} = \frac{s_\ell[a]}{\ell_\ell^0}\,e_\ell^\top.
  \]
  \item Build the three shear measurement rows:
  \[
  r_{\ell m}^{(a)} =
  \tfrac12\left(
  \frac{s_\ell[a]}{\ell_\ell^0}e_m^\top
  +
  \frac{s_m[a]}{\ell_m^0}e_\ell^\top
  \right).
  \]
  \item Compute the volume gradients $g_a$ from the reference vertices $X_a$ via
  the cross–product formulas above, and form the volumetric rows
  $r_{\mathrm{vol}}^{(a)}=(g_a/V_k)^\top$.
  \item For each element, evaluate the outer products in
  \eqref{eq:element_K_accum} and accumulate the resulting $12\times12$ block
  into the global sparse matrix builder, using the local–to–global DOF mapping
  and skipping constrained DOFs.
\end{enumerate}

\subsubsection{Torch CSR assembly (rows, cols, vals)}

On the GPU (we use CUDA here) we assemble the global free–DOF stiffness matrix in
triplet form and then convert to CSR. Only three one–dimensional tensors are
required:
\begin{itemize}
  \item \verb|rows[nnz]| (int64): row indices of nonzeros,
  \item \verb|cols[nnz]| (int64): column indices of nonzeros,
  \item \verb|vals[nnz]| (float32): values of nonzeros.
\end{itemize}

Triplets are emitted by a GPU kernel with the following logic:
\begin{itemize}
  \item For each element, map its 12 local DOFs to global free–DOF indices using
  a compressed \verb|dof_map| (constrained entries are \verb|-1| and skipped).
  \item Evaluate the three SMS contributions (axial, shear, volumetric) by
  computing the corresponding inner products of the precomputed row vectors and
  forming the scalar contribution for each local pair.
  \item For every local pair $(p,q)$ with valid global indices $(g_p,g_q)$,
  append one triplet
  \[
  (\texttt{rows[idx]} = g_p,\;
   \texttt{cols[idx]} = g_q,\;
   \texttt{vals[idx]} = \text{val})
  \]
  using an atomic counter to increment \verb|idx|.
\end{itemize}

The triplet buffers are allocated with a conservative capacity (for example
$144M$ entries for $M$ tetrahedra), but only the first $\texttt{nnz}$ slots are
actually written. After kernel execution we:
\begin{enumerate}
  \item Record the number of written entries, $nnz$.
  \item Slice all three arrays to length $nnz$:
  \[
  \texttt{rows} \leftarrow \texttt{rows}[:nnz],\quad
  \texttt{cols} \leftarrow \texttt{cols}[:nnz],\quad
  \texttt{vals} \leftarrow \texttt{vals}[:nnz].
  \]
\end{enumerate}

This truncation is crucial:
\begin{itemize}
  \item \textbf{Capacity vs.\ actual writes:} the buffers are over–allocated,
  but only the first $nnz$ entries are valid.
  \item \textbf{Correct COO construction:} the COO tensor requires that the
  index arrays and value array all have the same, correct length, namely the
  actual number of nonzeros.
  \item \textbf{Avoid garbage data:} leaving uninitialized buffer tails would
  introduce spurious entries (often explicit zeros) that corrupt the sparsity
  pattern and slow down the solver.
  \item \textbf{Performance:} smaller sliced arrays reduce data transfer and
  speed up the subsequent duplicate–combining pass.
  \item \textbf{Natural FE workflow:} many elements contribute to the same
  global $(\text{row},\text{col})$, so duplicates are expected. The workflow is
  \emph{emit triplets $\to$ slice to $nnz$ $\to$ combine duplicates by sum
  $\to$ convert to CSR}.
\end{itemize}

We then:
\begin{enumerate}
  \item Build a Torch COO sparse tensor from \verb|rows|, \verb|cols|, and
  \verb|vals|.
  \item Coalesce it (combining duplicate entries by summation).
  \item Convert the coalesced COO tensor to CSR; the row–pointer array
  (\verb|crow_indices|) is created internally by the framework.
\end{enumerate}

\subsubsection{Build RHS and solve}

On the free DOFs, the gravity RHS is built by mapping each free node index to
its three displacement DOFs and adding
\[
f_F[i_x,i_y,i_z] \mathrel{+}= m_i\,g.
\]
Surface traction or pressure loads are added similarly, by accumulating the
per‑node contributions into $f_F$ via the DOF map.

Finally, we solve the CSR system
\[
K_{FF}u_F = f_F
\]
The resulting free displacement vector $u_F$ is then scattered back into the
full displacement field $\vect{u}$ and used to update the deformed nodal
positions $\vect{X}=\vect{x}+\vect{u}$.


\subsection{Results}
\subsubsection{A Droop Cone Verification}

\subsubsection{Emory 4D-CT Image}



% \section{Sample Section}
% \subsection{A Subsection Sample}
% Please note that the first paragraph of a section or subsection is
% not indented. The first paragraph that follows a table, figure,
% equation etc. does not need an indent, either.

% Subsequent paragraphs, however, are indented.

% \subsubsection{Sample Heading (Third Level)} Only two levels of
% headings should be numbered. Lower level headings remain unnumbered;
% they are formatted as run-in headings.

% \paragraph{Sample Heading (Fourth Level)}
% The contribution should contain no more than four levels of
% headings. Table~\ref{tab1} gives a summary of all heading levels.

% \begin{table}
% \caption{Table captions should be placed above the
% tables.}\label{tab1}
% \begin{tabular}{|l|l|l|}
% \hline
% Heading level &  Example & Font size and style\\
% \hline
% Title (centered) &  {\Large\bfseries Lecture Notes} & 14 point, bold\\
% 1st-level heading &  {\large\bfseries 1 Introduction} & 12 point, bold\\
% 2nd-level heading & {\bfseries 2.1 Printing Area} & 10 point, bold\\
% 3rd-level heading & {\bfseries Run-in Heading in Bold.} Text follows & 10 point, bold\\
% 4th-level heading & {\itshape Lowest Level Heading.} Text follows & 10 point, italic\\
% \hline
% \end{tabular}
% \end{table}


% \noindent Displayed equations are centered and set on a separate
% line.
% \begin{equation}
% x + y = z
% \end{equation}
% Please try to avoid rasterized images for line-art diagrams and
% schemas. Whenever possible, use vector graphics instead (see
% Fig.~\ref{fig1}).

% \begin{figure}
% \caption{A figure caption is always placed below the illustration.
% Please note that short captions are centered, while long ones are
% justified by the macro package automatically.} \label{fig1}
% \end{figure}

% \begin{theorem}
% This is a sample theorem. The run-in heading is set in bold, while
% the following text appears in italics. Definitions, lemmas,
% propositions, and corollaries are styled the same way.
% \end{theorem}
% %
% % the environments 'definition', 'lemma', 'proposition', 'corollary',
% % 'remark', and 'example' are defined in the LLNCS documentclass as well.
% %
% \begin{proof}
% Proofs, examples, and remarks have the initial word in italics,
% while the following text appears in normal font.
% \end{proof}
% For citations of references, we prefer the use of square brackets
% and consecutive numbers. Citations using labels or the author/year
% convention are also acceptable. The following bibliography provides
% a sample reference list with entries for journal
% articles~\cite{ref_article1}, an LNCS chapter~\cite{ref_lncs1}, a
% book~\cite{ref_book1}, proceedings without editors~\cite{ref_proc1},
% and a homepage~\cite{ref_url1}. Multiple citations are grouped
% \cite{ref_article1,ref_lncs1,ref_book1},
% \cite{ref_article1,ref_book1,ref_proc1,ref_url1}.
% %
% % ---- Bibliography ----
% %
% % BibTeX users should specify bibliography style 'splncs04'.
% % References will then be sorted and formatted in the correct style.
% %
\bibliographystyle{splncs04}
\bibliography{mybibliography}
%

\end{document}
