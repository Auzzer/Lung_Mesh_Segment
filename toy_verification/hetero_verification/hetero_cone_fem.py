"""
Solve heterogeneous cone droop with per-tetrahedron material properties.

HETEROGENEOUS CONE SIMULATION OVERVIEW:
This module implements a two-region heterogeneous finite element simulation of a cone
subjected to gravitational loading with clamped top boundary condition.

WORKFLOW:
1. MESH & REGION LOADING:
   - Load tetrahedral cone mesh from cone.xdmf (generated by hetero_cone_gen.py)  
   - Region labels (0=background, 1=special) embedded in mesh cell data
   - See SPECIAL REGION DEFINITION below for geometric criteria

2. MATERIAL PROPERTY GENERATION:
   - build_material_fields() creates per-element E, rho, nu fields based on labels
   - Background region: baseline material properties
   - Special region: multiplied properties (e.g., 1.5x stiffer)
   - Random fluctuations added to both regions for material heterogeneity
   
3. LAMÉ PARAMETER CONVERSION:
   - Convert (E, nu) -> (mu, lambda) for linear elasticity formulation
   - mu = E/(2(1+nu)), lambda = E*nu/((1+nu)(1-2*nu))
   - Converted to DG0 functions for element-wise constant material properties
   
4. FEM SOLUTION:
   - Weak form: integral sigma(u):epsilon(v) dx = integral rho*g·v dx
   - Constitutive: sigma(u) = 2*mu*epsilon(u) + lambda*tr(epsilon(u))*I  
   - Boundary: top face clamped (u=0), free boundary elsewhere
   - Solve linear system using FEniCS

5. OUTPUT:
   - XDMF visualization files saved to xdmf_visualization/:
     * cone_fem_initial.xdmf: Initial mesh configuration with region labels
     * cone_fem_droop.xdmf: Deformed mesh after gravitational loading
   - Consolidated FEM data saved to cone_data/cone_fem_droop.npz:
     * initial_pos: Initial vertex positions (N_vertices, 3)
     * obs_pos: Observed/deformed vertex positions (N_vertices, 3)
     * tetra_param: Material properties per tetrahedron (N_tets, 5) = [E, rho, nu, mu, lambda]
     * tets: Tetrahedron connectivity (N_tets, 4)
     * labels: Region labels per tetrahedron (N_tets,)
     * Plus simulation metadata (seed, multipliers, base properties, etc.)
   - Can be used for homogenization verification against SMS methods

SPECIAL REGION DEFINITION (from hetero_cone_gen.py):
The special region (label=1) is defined by the intersection of three geometric criteria:

1. HEIGHT BAND: Tetrahedron centroids between normalized z-heights of 0.30 to 0.70
   - Computed as: mid_center ± band_width/2 = 0.50 ± 0.40/2
   - z=0 corresponds to cone base, z=1 to cone apex

2. RADIAL RANGE: Centroids between 0% and 100% of local cone surface radius
   - r_frac_min = 0.0 (includes central axis)
   - r_frac_max = 1.00 (includes full cone surface)
   - Radial fraction computed relative to local cone radius at each height

3. AZIMUTHAL WEDGE: Angular sector ±60° around +X axis (total 120° opening)
   - theta_center = 0.0 rad (wedge points along +X axis)
   - wedge_width = 2.0944 rad (120° total opening)

Result: A pie-slice shaped frustum segment in the middle 40% of the cone,
        extending from axis to surface over a 120° azimuthal sector.

MATERIAL REGIONS:
- Background region (label=0): Majority of cone volume with baseline properties
  - E = 1.0e4 Pa, rho = 200 kg/m³, nu = 0.4
- Special region (label=1): Wedge-shaped inclusion with modified properties
  - E = 2.0e4 Pa (2x stiffer), rho = 200 kg/m³, nu = 0.4
- Default: Special region is 2x stiffer than background (E_special_mult=2.0)
"""
from __future__ import annotations

from pathlib import Path
from typing import Dict, Optional, Tuple

import fenics as fe
import meshio
import numpy as np


def load_mesh_points_and_labels(mesh_path: Path) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    mesh = meshio.read(mesh_path)
    tets = mesh.get_cells_type("tetra")
    if "labels" in mesh.cell_data:
        label_data = mesh.cell_data["labels"][0]
    else:
        cell_data_dict = mesh.cell_data_dict.get("tetra", {})
        if "labels" in cell_data_dict:
            label_data = cell_data_dict["labels"]
    labels = np.asarray(label_data, dtype=np.int32)
    
    return mesh.points.copy(), tets.copy(), labels


def build_material_fields(
    labels: np.ndarray,
    background_fluctuation: float,
    seed: Optional[int],
    E_base: float,
    rho_base: float, 
    nu: float,
    E_special_mult: float = 1.5,
    rho_special_mult: float = 1.0,
) -> Dict[str, np.ndarray]:
    """
    Build material fields with background (label=0) and special (label=1) regions.
    
    HETEROGENEOUS MATERIAL COEFFICIENT GENERATION:
    This function generates per-element material properties for the two-region heterogeneous cone:
    
    1. REGION LABELING (input):
       - labels[i] = 0: Background region (majority of cone volume)  
       - labels[i] = 1: Special region (defined by geometric criteria in cone_region.py)
       
    2. MATERIAL ASSIGNMENT MODES:
       
       MULTIPLIER MODE (default, used here):
       - Background region (label=0): E = E_base, rho = rho_base, nu = nu
       - Special region (label=1):    E = E_base * E_special_mult, rho = rho_base * rho_special_mult, nu = nu
       
       DEFAULT VALUES (from main function):
       - E_base = 1e4 Pa, rho_base = 200.0 kg/m^3, nu = 0.4
       - E_special_mult = 2.0, rho_special_mult = 1.0
       
       RESULTING MATERIAL PROPERTIES:
       - Background region: E = 1.0e4 Pa, rho = 200 kg/m^3, nu = 0.4
       - Special region:    E = 2.0e4 Pa, rho = 200 kg/m^3, nu = 0.4 (2x stiffer)
       
    3. LAMÉ PARAMETERS COMPUTATION:
       For linear elasticity sigma(u) = 2*mu*epsilon(u) + lambda*tr(epsilon(u))*I, we compute:
       - mu = E / (2(1 + nu))           (shear modulus)  
       - lambda = E*nu / ((1 + nu)(1 - 2*nu))  (first Lamé parameter)
       
       With default values:
       - Background: mu ~= 3571.4 Pa, lambda ~= 14285.7 Pa
       - Special:    mu ~= 7142.9 Pa, lambda ~= 28571.4 Pa (2x the background)
       
    4. RANDOM FLUCTUATIONS:
       With background_fluctuation=0.0, materials are uniform within each region.
       (Set to non-zero value to add random variations simulating material heterogeneity)
       
    5. USAGE IN FEM:
       The resulting mu_cells, lambda_cells, rho_cells are converted to DG0 functions and used in:
       - Stiffness bilinear form: a = integral sigma(du):epsilon(v) dx  
       - Body force linear form:  L = integral rho*g·v dx
    """
    rng = np.random.default_rng(seed)
    n = labels.shape[0]
    
    # Simple approach: base values for background, multiplied values for special regions
    E_cells = np.full(n, E_base)
    rho_cells = np.full(n, rho_base)
    nu_cells = np.full(n, nu)
    
    # Apply multipliers to special regions (label=1)
    special_mask = (labels == 1)
    if np.any(special_mask):
        E_cells[special_mask] *= E_special_mult
        rho_cells[special_mask] *= rho_special_mult
    
    # Add random fluctuations
    E_cells *= (1.0 + rng.uniform(-background_fluctuation, background_fluctuation, size=n))
    rho_cells *= (1.0 + rng.uniform(-background_fluctuation, background_fluctuation, size=n))

    mu_cells = E_cells / (2.0 * (1.0 + nu_cells))
    lambda_cells = E_cells * nu_cells / ((1.0 + nu_cells) * (1.0 - 2.0 * nu_cells))

    return {
        "E_cells": E_cells,
        "rho_cells": rho_cells,
        "nu_cells": nu_cells,
        "mu_cells": mu_cells,
        "lambda_cells": lambda_cells,
        "seed": seed,
    }


def assemble_dg0_function(space: fe.FunctionSpace, values: np.ndarray) -> fe.Function:
    func = fe.Function(space)
    func.vector().set_local(values)
    func.vector().apply("insert")
    return func


def solve_cone_droop(
    mesh_path: Path,
    output_dir: Path,
    E: float,
    rho: float,
    nu: float,
    g_vec: Tuple[float, float, float],
    top_tol: float,
    background_fluctuation: float,
    E_special_mult: float,
    rho_special_mult: float,
    seed: Optional[int],
    region_params: Optional[Dict[str, float]] = None,
) -> Dict[str, np.ndarray]:
    """
    Solve heterogeneous cone droop using standard linear elasticity FEM.
    
    This function provides the "ground truth" reference solution for homogenization
    verification. The heterogeneous material properties are resolved at the 
    tetrahedral element level, giving the exact response of the two-region composite.
    
    HOMOGENIZATION VERIFICATION WORKFLOW:
    1. This FEM solver provides fine-scale "reference" displacement field
    2. The same geometry/loading can be solved using homogenized SMS methods  
    3. Displacement differences quantify homogenization accuracy
    4. Material coefficients (mu, lambda) can be used for SMS parameter calibration
    
    The output displacement field and material properties serve as input for
    SMS-based homogenization approaches in the hetero_verification workflow.
    """
    mesh = fe.Mesh()
    with fe.XDMFFile(fe.MPI.comm_world, str(mesh_path)) as xdmf:
        xdmf.read(mesh)

    points, tets, labels = load_mesh_points_and_labels(mesh_path)
    material = build_material_fields(
        labels,
        background_fluctuation=background_fluctuation,
        seed=seed,
        E_base=E,
        rho_base=rho,
        nu=nu,
        E_special_mult=E_special_mult,
        rho_special_mult=rho_special_mult,
    )

    V = fe.VectorFunctionSpace(mesh, "P", 1)
    DG0 = fe.FunctionSpace(mesh, "DG", 0)

    mu = assemble_dg0_function(DG0, material["mu_cells"])
    lmbda = assemble_dg0_function(DG0, material["lambda_cells"])
    rho_field = assemble_dg0_function(DG0, material["rho_cells"])

    g = fe.Constant(g_vec)
    f = fe.as_vector(tuple(rho_field * g[i] for i in range(3)))

    coords = mesh.coordinates()
    z_max = float(coords[:, 2].max())

    class TopBoundary(fe.SubDomain):
        def inside(self, x, on_boundary):  # type: ignore[override]
            return on_boundary and fe.near(x[2], z_max, top_tol)

    u = fe.Function(V)
    du = fe.TrialFunction(V)
    v = fe.TestFunction(V)
    d = u.geometric_dimension()
    I = fe.Identity(d)

    def epsilon(w):
        return fe.sym(fe.grad(w))

    def sigma(w):
        return 2.0 * mu * epsilon(w) + lmbda * fe.tr(epsilon(w)) * I

    a = fe.inner(sigma(du), epsilon(v)) * fe.dx
    L = fe.dot(f, v) * fe.dx

    zero = fe.Constant((0.0, 0.0, 0.0))
    bc_top = fe.DirichletBC(V, zero, TopBoundary())

    fe.solve(a == L, u, bcs=[bc_top])

    u_vertex = u.compute_vertex_values(mesh).reshape((d, -1)).T
    disp_mag = np.linalg.norm(u_vertex, axis=1)
    print(f"Solved droop: |u|_max={disp_mag.max():.6e}, |u|_mean={disp_mag.mean():.6e}")

    final_vertices = coords + u_vertex
    out_dir = output_dir
    out_dir.mkdir(parents=True, exist_ok=True)
    
    # Save XDMF visualization files
    xdmf_dir = out_dir / "xdmf_visualization"
    xdmf_dir.mkdir(parents=True, exist_ok=True)
    
    # Save initial mesh with labels
    initial_mesh = meshio.Mesh(points=coords, cells=[("tetra", tets)], cell_data={"labels": [labels]})
    initial_path = xdmf_dir / "cone_fem_initial.xdmf"
    meshio.write(initial_path, initial_mesh, data_format="XML")
    print(f"Initial mesh written: {initial_path}")
    
    # Save deformed mesh with labels
    deformed_mesh = meshio.Mesh(points=final_vertices, cells=[("tetra", tets)], cell_data={"labels": [labels]})
    droop_path = xdmf_dir / "cone_fem_droop.xdmf"
    meshio.write(droop_path, deformed_mesh, data_format="XML")
    print(f"Deformed mesh written: {droop_path}")

    # Save consolidated data file
    data_dir = out_dir / "cone_data"
    data_dir.mkdir(parents=True, exist_ok=True)
    
    # Prepare tetra_param: material properties per tetrahedron
    tetra_param = np.column_stack([
        material["E_cells"],
        material["rho_cells"],
        material["nu_cells"],
        material["mu_cells"],
        material["lambda_cells"],
    ])
    
    np.savez(
        data_dir / "cone_fem_droop.npz",
        initial_pos=coords,
        obs_pos=final_vertices,
        tetra_param=tetra_param,
        tets=tets,
        labels=labels,
        E_cells=material["E_cells"],
        rho_cells=material["rho_cells"],
        nu_cells=material["nu_cells"],
        mu_cells=material["mu_cells"],
        lambda_cells=material["lambda_cells"],
        seed=seed,
        background_fluctuation=background_fluctuation,
        E_special_mult=E_special_mult,
        rho_special_mult=rho_special_mult,
        E_base=E,
        rho_base=rho,
        nu_base=nu,
        region_params=region_params,
    )
    print(f"FEM data saved: {data_dir / 'cone_fem_droop.npz'}")

    return material


def main() -> None:
    """
    HETEROGENEOUS CONE SIMULATION - DEFAULT PARAMETERS:
    
    This function sets up and runs a heterogeneous cone droop simulation with two material regions.
    The workflow combines geometric region definition with material property assignment:
    
    1. GEOMETRIC PARAMETERS:
       - Cone mesh loaded from cone.xdmf (generated by hetero_cone_gen.py)
       - Region labels (0=background, 1=special) embedded in mesh cell data
       - Special region defined by geometric criteria (see module docstring)
       
    2. BASELINE MATERIAL PROPERTIES:
       - E = 1e4 Pa        (Young's modulus for background region)
       - rho = 200.0 kg/m^3 (density, same for both regions) 
       - nu = 0.4          (Poisson ratio, same for both regions)
       
    3. HETEROGENEITY MULTIPLIERS:
       - E_special_mult = 2.0   (special region is 2x stiffer)  
       - rho_special_mult = 1.0 (density unchanged between regions)
       
    4. SIMULATION PARAMETERS:
       - g = (0, 0, -9.81) m/s^2 (gravity load)
       - background_fluctuation = 0.0 (no random material variation)
       - Top face clamped (zero displacement boundary condition)
       
    MATERIAL COEFFICIENT SUMMARY:
    - Background region (label=0): E=1.0e4 Pa, mu ~= 3571.4 Pa, lambda ~= 14285.7 Pa
    - Special region (label=1):    E=2.0e4 Pa, mu ~= 7142.9 Pa, lambda ~= 28571.4 Pa (2x background)
    - Both regions: rho=200 kg/m^3, nu=0.4, uniform material properties (no fluctuations)
    
    The resulting heterogeneous material field is used in linear elasticity FEM
    with sigma(u) = 2*mu*epsilon(u) + lambda*tr(epsilon(u))*I and body force f = rho*g.
    """
    base_dir = Path(__file__).resolve().parent
    xdmf_dir = base_dir / "xdmf_visualization"
    mesh_path = xdmf_dir / "cone.xdmf"
    output_dir = base_dir
    E = 1e4                      # Young's modulus baseline (Pa)
    rho = 200.0                  # Density (kg/m^3)
    nu = 0.4                     # Poisson ratio
    g = (0.0, 0.0, -9.81)       # Gravity acceleration (m/s^2)
    top_tol = 1e-4               # Tolerance for top face boundary detection
    background_fluctuation = 0.0 # No random material variation
    E_special_mult = 2.0         # Elastic modulus multiplier for special region (2x stiffer)
    rho_special_mult = 1.0       # Density multiplier for special region (unchanged)
    seed = None                  # Random seed for reproducible fluctuations
    
    # Region parameters for documentation (embedded in mesh, not loaded from file)
    region_params_doc = {
        "mid_center": 0.50,
        "band_width": 0.40,
        "theta_center": 0.0,
        "wedge_width": 2.0944,  # 120 degrees in radians
        "r_frac_min": 0.0,
        "r_frac_max": 1.00,
    }
    
    print("Special region parameters (for reference, embedded in mesh labels):")
    for key, value in region_params_doc.items():
        if key.startswith("theta") or key.startswith("wedge"):
            print(f"  {key}: {value:.4f} rad ({np.rad2deg(value):.1f}°)")
        else:
            print(f"  {key}: {value:.4f}")

    solve_cone_droop(
        mesh_path=mesh_path,
        output_dir=output_dir,
        E=E,
        rho=rho,
        nu=nu,
        g_vec=g,
        top_tol=top_tol,
        background_fluctuation=background_fluctuation,
        E_special_mult=E_special_mult,
        rho_special_mult=rho_special_mult,
        seed=seed,
        region_params=region_params_doc,
    )


if __name__ == "__main__":
    main()
